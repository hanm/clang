//=== Constraints.cpp - Effect Inclusion Constraint *- C++ ---------*===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------===//
//
// This file defines Constraints generated by the Safe Parallelism checker
// and emmitted to Prolog for solving.
//
//===----------------------------------------------------------------===//
#include <fstream>

#include "ASaPSymbolTable.h"
#include "Constraints.h"
#include "Effect.h"

namespace clang {
namespace asap {

//////////////////////////////////////////////////////////////////////////
//  Constraint

term_t Constraint::getIDPLTerm() const {
  term_t IDTerm = PL_new_term_ref();
  PL_put_atom_chars(IDTerm, ConstraintID.data());
  return IDTerm;
}

void Constraint::emitGraphNode(std::ofstream &OutF) const {
  OutF << ConstraintID.data() << "["
       << "color=" << getNodeColor();
  if (Kind == CK_EffectNonInterference)
    OutF << ", style=filled, fillcolor=" << getNodeColor();
  OutF << "]" << std::endl;
}

void Constraint::emitGraphEdges(std::ofstream &OutF,
                                const std::string &EdgeOp,
                                const std::string &EdgeColor,
                                const VarRplSetT *VRS) const {
  for (VarRplSetT::const_iterator I = VRS->begin(), E = VRS->end();
       I != E; ++I) {
    const VarRpl *R = *I;
    assert(R && "Internal Error: unexpected null pointer");
    OutF << getConstraintID().data() << " " << EdgeOp << " " << R->getID().data()
         << " [color=" << EdgeColor << "]"
         << std::endl;
  }
}

void Constraint::emitGraphEdges(std::ofstream &OutF,
                                const std::string &EdgeOp,
                                const std::string &EdgeColor,
                                const VarEffectSummarySetT *VRS) const {
  for (VarEffectSummarySetT::const_iterator
          I = VRS->begin(),
          E = VRS->end();
        I != E; ++I) {
    const VarEffectSummary *ES = *I;
    assert(ES && "Internal Error: unexpected null pointer");
    OutF << getConstraintID().data() << " " << EdgeOp << " " << ES->getID().data()
         << " [color=" << EdgeColor << "]"
         << std::endl;
  }
}

//////////////////////////////////////////////////////////////////////////
//  RplInclusionConstraint

term_t RplInclusionConstraint::getPLTerm() const {

  term_t RICTerm  = PL_new_term_ref();
  functor_t RICFunctor =
    PL_new_functor(PL_new_atom(PL_RIConstraint.c_str()), 3);
  int Res = PL_cons_functor(RICTerm, RICFunctor, getIDPLTerm(),
                            LHS->getPLTerm(), RHS->getPLTerm());
  assert(Res && "Failed to build 'esi_constraint' Prolog term");

  return RICTerm;
}

void RplInclusionConstraint::print(llvm::raw_ostream &OS) const {
  OS << "RplInclusionConstraint(" << getConstraintID() << "): "
     << LHS->toString() << " <=(Incl) "
     << RHS->toString();
}

VarRplSetT *RplInclusionConstraint::collectRplVars() const {
  VarRplSetT *L = LHS->collectRplVars();
  VarRplSetT *R = RHS->collectRplVars();
  return mergeRVSets(L, R);
}

void RplInclusionConstraint::emitGraphEdges(std::ofstream &OutF,
                                            const std::string &EdgeOp) const {
  VarRplSetT *VRS = LHS->collectRplVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_LHSEdgeColor, VRS);
  delete VRS;
  VRS = RHS->collectRplVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_RHSEdgeColor, VRS);
  delete VRS;
}

RplInclusionConstraint::~RplInclusionConstraint() {
  delete LHS;
  delete RHS;
}
//////////////////////////////////////////////////////////////////////////
//  EffectInclusionConstraint

EffectInclusionConstraint::
EffectInclusionConstraint(StringRef ID,
                          const ConcreteEffectSummary *Lhs,
                          const EffectSummary *Rhs,
                          const FunctionDecl *Def,
                          const Stmt *S)
                         : Constraint(CK_EffectInclusion, ID),
                           RHS(Rhs), Def(Def), S(S) {
  LHS = new EffectVector();
  if (Lhs) {
    LHS->addEffects(*Lhs);
  }
}

EffectInclusionConstraint::~EffectInclusionConstraint() {
  delete LHS;
}

void EffectInclusionConstraint::addEffect(const Effect *Eff) {
  LHS->push_back(Eff);
}

void EffectInclusionConstraint::addEffect(std::unique_ptr<Effect> &Eff) {
  LHS->push_back(Eff);
}

void EffectInclusionConstraint::addEffects(const ConcreteEffectSummary &ES) {
  LHS->addEffects(ES);
}

term_t EffectInclusionConstraint::getPLTerm() const {
  assert(Def && "Internal Error: Trying to create prolog term with mising declaration");
  // Build ESI_ID term
  term_t ESIID = getIDPLTerm();

  // Build LHS term (list of effects that must be inlcuded)
  term_t LHSTerm = LHS->getPLTerm();

  // Build RHS term (usually an effect summary variable)
  term_t RHSTerm = RHS->getPLTerm();

  term_t ESITerm  = PL_new_term_ref();
  functor_t ESIFunctor =
    PL_new_functor(PL_new_atom(PL_ESIConstraint.c_str()), 3);
  int Res = PL_cons_functor(ESITerm, ESIFunctor, ESIID, LHSTerm, RHSTerm);
  assert(Res && "Failed to build 'esi_constraint' Prolog term");

  return ESITerm;
}

void EffectInclusionConstraint::print(llvm::raw_ostream &OS) const {
  assert(LHS && "Unexpected null-pointer LHS in EffectInclusionConstraint");
  assert(RHS && "Unexpected null-pointer RHS in EffectInclusionConstraint");
  OS << "EffectInclusionConstraint(" << getConstraintID() << "): {";
  EffectVector::const_iterator I = LHS->begin(), E = LHS->end();
  if (I != E) {
    (*I)->print(OS);
    ++I;
  }
  for (; I != E; ++I) {
    //OS << (*I)->toString();
    OS << ", ";
    (*I)->print(OS);
  }
  OS << "} <=(Incl) ";
  RHS->print(OS);
}

void EffectInclusionConstraint::makeMinimal() {
  if (LHS)
    LHS->makeMinimal();
}

VarRplSetT *EffectInclusionConstraint::collectRplVars() const {
  VarRplSetT *L = LHS->collectRplVars();
  VarRplSetT *R = RHS->collectRplVars();
  return mergeRVSets(L, R);
}

VarEffectSummarySetT *EffectInclusionConstraint::collectEffectSummaryVars() const {
  VarEffectSummarySetT *L = LHS->collectEffectSummaryVars();
  VarEffectSummarySetT *R = RHS->collectEffectSummaryVars();
  return mergeESVSets(L, R);
}

void EffectInclusionConstraint::emitGraphEdges(std::ofstream &OutF,
                                               const std::string &EdgeOp) const {
  VarRplSetT *VRS = LHS->collectRplVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_LHSEdgeColor, VRS);
  delete VRS;
  VRS = RHS->collectRplVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_RHSEdgeColor, VRS);
  delete VRS;
  VarEffectSummarySetT *VES = LHS->collectEffectSummaryVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_LHSEdgeColor, VES);
  delete VES;
  VES = RHS->collectEffectSummaryVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_RHSEdgeColor, VES);
  delete VES;
}


void EffectInclusionConstraint::emitCallGraphEdges(std::ofstream &OutF,
                                                   const std::string &EdgeOp) const {
  // Iterate through LHS creating an edge for each invokes effect
  for(EffectVector::const_iterator I = LHS->begin(), E = LHS->end(); I != E; ++I) {
    const Effect *Ef = *I;
    if (Ef->isCompound()) {
      OutF << SymbolTable::Table->getPrologName(Def).data() << " " << EdgeOp
           << SymbolTable::Table->getPrologName(Ef->getDecl()).data()
           << std::endl;
    }
  }
}
//////////////////////////////////////////////////////////////////////////
//  EffectNIConstraint

EffectNIConstraint::
EffectNIConstraint( StringRef ID,
                    const EffectSummary &ES1,
                    const EffectSummary &ES2)
                  : Constraint(CK_EffectNonInterference, ID),
                    LHS(ES1.clone()),
                    RHS(ES2.clone()) {}

term_t EffectNIConstraint::getPLTerm() const {
  term_t ENITerm = PL_new_term_ref();
  functor_t ENIFunctor =
    PL_new_functor(PL_new_atom(PL_ENIConstraint.c_str()), 3);
  assert(LHS && "Unexpected null-pointer LHS");
  assert(RHS && "Unexpected null-pointer RHS");
  int Res = PL_cons_functor(ENITerm, ENIFunctor, getIDPLTerm(),
                            LHS->getPLTerm(), RHS->getPLTerm());
  assert(Res && "Failed to build 'esi_constraint' Prolog term");

  return ENITerm;

}

void EffectNIConstraint::print(llvm::raw_ostream &OS) const {
  assert(LHS && "Unexpected null-pointer LHS in EffectNIConstraint");
  assert(RHS && "Unexpected null-pointer RHS in EffectNIConstraint");
  OS << "EffectNonInterferenceConstraint(" << getConstraintID() << "): "
     << LHS->toString() << " # " << RHS->toString();
}

EffectNIConstraint::~EffectNIConstraint() {
  delete LHS;
  delete RHS;
}

VarRplSetT *EffectNIConstraint::collectRplVars() const {
  VarRplSetT *L = LHS->collectRplVars();
  VarRplSetT *R = RHS->collectRplVars();
  return mergeRVSets(L, R);
}

VarEffectSummarySetT *EffectNIConstraint::collectEffectSummaryVars() const {
  VarEffectSummarySetT *L = LHS->collectEffectSummaryVars();
  VarEffectSummarySetT *R = RHS->collectEffectSummaryVars();
  return mergeESVSets(L, R);
}

void EffectNIConstraint::emitGraphEdges(std::ofstream &OutF,
                                        const std::string &EdgeOp) const {
  VarRplSetT *VRS = LHS->collectRplVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_LHSEdgeColor, VRS);
  delete VRS;
  VRS = RHS->collectRplVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_RHSEdgeColor, VRS);
  delete VRS;
  VarEffectSummarySetT *VES = LHS->collectEffectSummaryVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_LHSEdgeColor, VES);
  delete VES;
  VES = RHS->collectEffectSummaryVars();
  Constraint::emitGraphEdges(OutF, EdgeOp, DOT_RHSEdgeColor, VES);
  delete VES;
}

} // end namespace asap
} // end namespace clang
