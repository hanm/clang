//=== Constraints.h - Effect Inclusion Constraint *- C++ -----------*===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------===//
//
// This file defines Constraints generated by the Safe Parallelism checker
// and emmitted to Prolog for solving.
//
//===----------------------------------------------------------------===//

#ifndef LLVM_CLANG_STATICANALYZER_CHECKERS_ASAP_CONSTRAINTS_H
#define LLVM_CLANG_STATICANALYZER_CHECKERS_ASAP_CONSTRAINTS_H

#include <SWI-Prolog.h>

#include "ASaPFwdDecl.h"
#include "Rpl.h"

namespace clang {
namespace asap {

// Abstract class, parent of all types of Constraints
class Constraint {
public:
  /// Discriminator for LLVM-style RTTI (dyn_cast<> et al.)
  enum ConstraintKind {
    CK_EffectInclusion,
    CK_RplInclusion,
    CK_EffectNonInterference
  };
private:
  const ConstraintKind Kind;
  StringRef ConstraintID;
public:
  Constraint(ConstraintKind K, StringRef ID) : Kind(K), ConstraintID(ID) {}

  StringRef getConstraintID() const { return ConstraintID; }
  ConstraintKind getKind() const { return Kind; }

  term_t getIDPLTerm() const;

  virtual term_t getPLTerm() const = 0;
  virtual void print(llvm::raw_ostream &OS) const = 0;

  inline std::string toString() const {
    std::string SBuf;
    llvm::raw_string_ostream OS(SBuf);
    print(OS);
    return std::string(OS.str());
  }

}; // end class Constraint

// class that represents an Rpl inclusion constraint.
class RplInclusionConstraint : public Constraint {
  const Rpl &LHS;
  const Rpl &RHS;

public:
  RplInclusionConstraint(StringRef ID, const Rpl &LHS, const Rpl &RHS)
                        : Constraint(CK_RplInclusion, ID),
                          LHS(*LHS.clone()), RHS(*RHS.clone()) {}

  virtual term_t getPLTerm() const;
  virtual void print(llvm::raw_ostream &OS) const;

  static bool classof(const Constraint *C) {
    return C->getKind() == CK_RplInclusion;
  }
}; // end RplInclusionConstraint

//class that represents an effect inclusion constraint.
class EffectInclusionConstraint : public Constraint {
  EffectVector *LHS;
  const EffectSummary *RHS;
  const FunctionDecl *Def;
  const Stmt *S;

 public:
  EffectInclusionConstraint(StringRef ID,
                            const EffectSummary *Rhs,
                            const FunctionDecl *Def,
                            const Stmt *S);

  virtual ~EffectInclusionConstraint() {}

  void addEffect(Effect *Eff);
  EffectVector *getLHS()  {return LHS;}
  const EffectSummary *getRHS() const {return RHS;}
  const FunctionDecl *getDef() const {return Def;}
  const Stmt *getS() const {return S;}
  void makeMinimal();

  virtual term_t getPLTerm() const;
  virtual void print(llvm::raw_ostream &OS) const;

  static bool classof(const Constraint *C) {
    return C->getKind() == CK_EffectInclusion;
  }
}; // end class EffectInclusionConstrain


//class that represents an effect inclusion constraint
class EffectNIConstraint : public Constraint {
  const EffectSummary *LHS;
  const EffectSummary *RHS;

 public:
  EffectNIConstraint(StringRef ID,
                     const EffectSummary *ES1,
                     const EffectSummary *ES2);

  const EffectSummary *getLHS() { return LHS; }
  const EffectSummary *getRHS() { return RHS; }

  virtual term_t getPLTerm() const;
  virtual void print(llvm::raw_ostream &OS) const;

  static bool classof(const Constraint *C) {
    return C->getKind() == CK_EffectNonInterference;
  }
}; // end class EffectNIConstraint

} // End namespace asap.
} // End namespace clang.
#endif

